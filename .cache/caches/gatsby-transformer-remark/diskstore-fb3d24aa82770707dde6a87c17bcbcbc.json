{"expireTime":9007200844641545000,"key":"transformer-remark-markdown-html-260047547560cf3a7b32750582f0890d-gatsby-remark-highlight-code-","val":"<p><strong>Selection sort</strong> é um dos muitos algoritmos de ordenação que existem no mundo da computação, este algoritmo tem a sua característica de ordenação baseada em <strong>iteração</strong>, <strong>selecção</strong> e <strong>troca</strong>.</p>\n<p>Imaginem que temos uma lista com os dados de mais ou menos dois mil estudantes, na qual nos foi pedido a ordenação da mesma conforme a idade e por ordem crescente.</p>\n\n        <deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">let students = [\n  { name: &quot;Joseana&quot;, age: 30 },\n  { name: &quot;Faustino&quot;, age: 24 },\n  { name: &quot;Ana&quot;, age: 43 },\n  { name: &quot;António&quot;, age: 28 },\n  { name: &quot;Clara&quot;, age: 19 },\n  // ... resto dos estudantes\n]</code>\n        </deckgo-highlight-code>\n      \n<p>Podemos ordernar esta lista usando o <strong>selection sort</strong> e seguindo os seguintes passos:</p>\n<ul>\n<li>Percorrer a lista, marcar o primeiro elemento da iteração como <code>pivot</code>.</li>\n<li>Encontrar um elemento que seja menor do que o <code>pivot</code> e também o menor da lista e que não esteja ordenado.</li>\n<li>Após o ter encontrado, trocamos a sua posição com o elemento <code>pivot</code>.</li>\n</ul>\n<p>Repetimos o mesmo processo até termos uma lista totalmente ordenada(por ordem crescente ou decrescente).</p>\n\n        <deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function selectionSort(list) {\n  const listSize = list.length\n  // iteramos sobre a lista de estudantes\n  for (let i = 0; i &lt; listSize - 1; i++) {\n    // marcamos o primeiro elemento da iteração como pivot\n    let pivot = i\n    // percorremos a lista começando do elemento à direita do pivot\n    for (let j = i + 1; j &lt; listSize; j++) {\n      // caso o elemento seja menor que o pivot e também o menor da lista\n      // então este elemento passa a ser o novo pivot\n      if (list[pivot].age &lt; list[j].age) {\n        pivot = j\n      }\n    }\n    // trocamos a posição do antigo pivot com o novo pivot\n    swapPlaces(list, i, pivot)\n  }\n  return list\n}\n\nfunction swapPlaces(list, i, smallest) {\n  const [a, b] = [list[i], list[smallest]]\n  list[smallest] = a\n  list[i] = b\n}</code>\n        </deckgo-highlight-code>\n      \n<p>Note que este algoritmo pode ser usado em Arrays, Linked Lists, ou qualquer outro tipo de lista iterável.\nA complexidade de tempo deste algoritmo é de <code>O(n^2)</code> visto que percorremos a lista duas vezes.</p>\n<p>Caso queira ter uma representação visual do funcionamento deste algoritmo: <a href=\"https://visualgo.net/bn/sorting\">https://visualgo.net/bn/sorting</a></p>"}